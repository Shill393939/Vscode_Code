# 1008笔记

## 83.删除链表中的重复元素

```C++
    /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *newhead = head;
        //链表里大都是while循环 next代替++
        while(newhead!=NULL&&newhead->next!=NULL) //null四个字母都是大写
        {
            if(newhead->val == newhead->next->val)
            {
                newhead->next = newhead->next->next;
            }// 指针要用箭头
            else
            {
                newhead = newhead->next;
            }

        }
        return head;
    }

};
```

## 155.最小栈

### 数据结构 堆栈  （stack 标准容器）

定义：管理一个序列，对该序列的主要操作是在序列的末尾插入元素和删除元素，有这类操作要求的序列，我们称之为堆栈。

```C++
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int>x_stack;
    stack<int>min_stack;
    MinStack() {
        min_stack.push(INT_MAX);
    }
    void push(int x) {
        x_stack.push(x);
        min_stack.push(min(min_stack.top(),x));
    }  
    void pop() {
        x_stack.pop();
        min_stack.pop(); //pop的时候要一起pop出去
    }
    int top() {
     return x_stack.top();
    }  
    int getMin() {
        return min_stack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 **/

```

## 255 用队列实现栈

队列只能在一端插入在另一端删除。“先入先出”

假溢出 ： 用循环队列解决

```C++
    class MyStack {
public:
    /** Initialize your data structure here. */
    queue<int> queue1;
    queue<int> queue2;

    MyStack() {

    }
    /** Push element x onto stack. */
    void push(int x) {
     queue2.push(x);
     while(!queue1.empty())
     {
         queue2.push(queue1.front());
         queue1.pop();
     }
     swap(queue1,queue2);
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int r = queue1.front();
        queue1.pop();
        return r;
    }
    /** Get the top element. */
    int top() {

        return queue1.front();
    }
    /** Returns whether the stack is empty. */
    bool empty() {
        return queue1.empty();

    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```
